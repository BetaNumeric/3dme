<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Interactive Me - Textured Particles</title>
    <style>
        /* Basic Reset & Layout */
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #050505; 
            overflow: hidden;
            touch-action: none; 
            user-select: none; 
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
            position: relative;
        }

        /* Loading Overlay */
        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid #00ffff;
            padding: 20px 40px;
            border-radius: 4px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.15);
            font-weight: bold;
            color: #00ffff;
            text-align: center;
            max-width: 80%;
            transition: opacity 0.5s ease;
            z-index: 10;
        }
        
        .hidden {
            opacity: 0;
            pointer-events: none;
        }

        .error-msg {
            color: #ff4444;
            font-size: 0.9em;
            margin-top: 10px;
            font-weight: normal;
        }

        /* DEBUG PANEL */
        #debug-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #444;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            padding: 15px;
            border-radius: 4px;
            pointer-events: none;
            z-index: 100;
            font-size: 13px;
            line-height: 1.6;
            display: none; 
            min-width: 200px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .debug-row {
            display: flex;
            justify-content: space-between;
        }
        
        .debug-val {
            font-weight: bold;
            color: #fff;
        }
        
        .val-good { color: #00ff00; }
        .val-warn { color: #ffff00; }
        .val-bad { color: #ff0000; }
    </style>
</head>
<body>

    <div id="canvas-container">
        <div id="loader">
            <div id="loader-text">Generating Particles...</div>
            <div id="error-details" class="error-msg"></div>
        </div>
        
        <!-- Debug Overlay -->
        <div id="debug-panel">
            <div style="border-bottom: 1px solid #444; margin-bottom: 8px; padding-bottom: 4px; color: #aaa;">DEBUG MODE</div>
            <div class="debug-row">FPS: <span id="db-fps" class="debug-val">0</span></div>
            <div class="debug-row">Particles: <span id="db-count" class="debug-val">0</span></div>
            <div class="debug-row">Buffer Cap: <span id="db-max" class="debug-val">0</span></div>
            <div class="debug-row">State: <span id="db-state" class="debug-val">IDLE</span></div>
            <div class="debug-row">Interaction: <span id="db-interact" class="debug-val">FALSE</span></div>
            <div class="debug-row">Radius: <span id="db-radius" class="debug-val">0.00</span></div>
        </div>
    </div>

    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- CONFIGURATION ---
        
        const USER = 'BetaNumeric';
        const REPO = '3DME';
        const BRANCH = 'main';
        const MODEL_FILE_NAME = 'model/me.glb'; 
        const MODEL_URL = `https://raw.githubusercontent.com/${USER}/${REPO}/${BRANCH}/${MODEL_FILE_NAME}`;
        
        const PARTICLE_COUNT = 1000000; 

        // --- DEBUG ELEMENTS ---
        const debugPanel = document.getElementById('debug-panel');
        const dbFps = document.getElementById('db-fps');
        const dbCount = document.getElementById('db-count');
        const dbMax = document.getElementById('db-max');
        const dbState = document.getElementById('db-state');
        const dbInteract = document.getElementById('db-interact');
        const dbRadius = document.getElementById('db-radius');
        
        let isDebugVisible = false;
        
        window.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && (e.key === 'D' || e.key === 'd')) {
                e.preventDefault();
                isDebugVisible = !isDebugVisible;
                debugPanel.style.display = isDebugVisible ? 'block' : 'none';
            }
        });

        // --- SHADERS ---
        
        const vertexShader = `
            uniform float uPixelRatio;
            uniform vec3 uMouse;
            
            attribute float aRandom;
            
            varying vec2 vUv;
            varying vec3 vPosition;
            varying float vDistance;

            void main() {
                vPosition = position;
                vUv = uv; 
                
                vDistance = distance(position, uMouse);

                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                gl_Position = projectionMatrix * mvPosition;
                
                float size = 1.0 + aRandom * 3.5;
                gl_PointSize = (size * uPixelRatio) / -mvPosition.z;
            }
        `;

        const fragmentShader = `
            uniform sampler2D uTexture; 
            uniform bool uUseTexture;   
            
            varying vec2 vUv;
            varying vec3 vPosition;
            varying float vDistance;

            void main() {
                if (distance(gl_PointCoord, vec2(0.5, 0.5)) > 0.5) discard;

                vec3 finalColor;

                if (uUseTexture) {
                    vec4 texColor = texture2D(uTexture, vUv);
                    finalColor = texColor.rgb * 1.2;
                } else {
                    vec3 color1 = vec3(0.0, 1.0, 0.8);
                    vec3 color2 = vec3(0.5, 0.0, 1.0);
                    float mixFactor = (vPosition.y + 1.0) * 0.5;
                    finalColor = mix(color2, color1, mixFactor);
                }
                
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        // --- SCENE SETUP ---
        
        const container = document.getElementById('canvas-container');
        const loaderElement = document.getElementById('loader');
        const loaderText = document.getElementById('loader-text');

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        scene.fog = new THREE.FogExp2(0x050505, 0.05);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 1, 3);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.minDistance = 1;
        controls.maxDistance = 10;
        controls.minAzimuthAngle = -Infinity;
        controls.maxAzimuthAngle = Infinity;
        controls.target.set(0, 0, 0);

        // --- INTERACTION STATE ---
        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(-100, -100);
        const dummyPlane = new THREE.Mesh(
            new THREE.PlaneGeometry(100, 100),
            new THREE.MeshBasicMaterial({ visible: false })
        );
        scene.add(dummyPlane);

        const mouse3D = new THREE.Vector3(0, 0, 0);
        const prevMouse3D = new THREE.Vector3(0, 0, 0);
        const mouseVelocity = new THREE.Vector3(0, 0, 0);
        
        let isDragging = false;      
        let isInteracting = false;   
        let swirlDirection = 1;      
        
        let lastInteractionTime = Date.now();
        const IDLE_TIMEOUT = 3000; 
        const ROTATION_TARGET_SPEED = 2.0; 
        
        let pulseIntensity = 0;

        const customUniforms = {
            uMouse: { value: new THREE.Vector3(0, 0, 0) },
            uPixelRatio: { value: window.devicePixelRatio },
            uTexture: { value: null },
            uUseTexture: { value: false }
        };

        // --- PHYSICS & PERFORMANCE DATA ---
        let particles = null;
        // Data Arrays
        let originalPositions = null;
        let currentPositions = null;
        let velocities = null;
        let particleRandoms = null; 
        let particleCount = 0; // The capacity of the current buffer
        
        let activeParticleCount = 0; // The number we are actually updating/drawing
        let lastFpsCheck = 0;
        let frameCount = 0;
        let lowFpsStreak = 0;

        // --- HELPER: Random Shuffle ---
        function shuffleIndices(count) {
            const indices = new Uint32Array(count);
            for (let i = 0; i < count; i++) indices[i] = i;
            for (let i = count - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [indices[i], indices[j]] = [indices[j], indices[i]];
            }
            return indices;
        }

        // --- HELPER: Buffer Compaction (Hard Optimization) ---
        // Creates smaller buffers and disposes the old ones to free VRAM/Bandwidth
        function compactBuffers(newCount) {
            console.log(`Compacting buffers: ${particleCount} -> ${newCount}`);
            
            // 1. Slice Arrays (Create copies of the active data)
            const newPos = currentPositions.slice(0, newCount * 3);
            const newOrig = originalPositions.slice(0, newCount * 3);
            const newVel = velocities.slice(0, newCount * 3);
            const newRand = particleRandoms.slice(0, newCount);
            
            // UVs need to be grabbed from geometry since we don't keep a ref
            const oldUv = particles.geometry.attributes.uv.array;
            const newUv = oldUv.slice(0, newCount * 2);

            // 2. Update References
            originalPositions = newOrig;
            velocities = newVel;
            particleRandoms = newRand;
            
            // 3. Create New Geometry
            const newGeo = new THREE.BufferGeometry();
            newGeo.setAttribute('position', new THREE.BufferAttribute(newPos, 3));
            newGeo.setAttribute('uv', new THREE.BufferAttribute(newUv, 2));
            newGeo.setAttribute('aRandom', new THREE.BufferAttribute(newRand, 1));
            
            // 4. Swap and Dispose
            particles.geometry.dispose(); // IMPORTANT: Frees GPU memory
            particles.geometry = newGeo;
            
            // 5. Re-link currentPositions to the new geometry's array
            currentPositions = particles.geometry.attributes.position.array;
            
            // 6. Update tracking variables
            particles.geometry.setDrawRange(0, newCount);
            particleCount = newCount; // Capacity is now smaller
            activeParticleCount = newCount;
            
            // Tell renderer this is a new object essentially
            particles.frustumCulled = false; 
        }

        // --- HELPER: Surface Sampler ---
        function sampleGeometry(geometry, count) {
            const positions = new Float32Array(count * 3);
            const uvs = new Float32Array(count * 2);
            
            const posAttr = geometry.attributes.position;
            const uvAttr = geometry.attributes.uv;
            const indexAttr = geometry.index;
            
            const getPos = (i, target) => {
                const idx = indexAttr ? indexAttr.getX(i) : i;
                target.fromBufferAttribute(posAttr, idx);
            };
            
            const getUv = (i, target) => {
                if (!uvAttr) return target.set(0,0);
                const idx = indexAttr ? indexAttr.getX(i) : i;
                target.fromBufferAttribute(uvAttr, idx);
            };

            const areas = [];
            let totalArea = 0;
            const faceCount = (indexAttr ? indexAttr.count : posAttr.count) / 3;
            
            const a = new THREE.Vector3(), b = new THREE.Vector3(), c = new THREE.Vector3();
            const uvA = new THREE.Vector2(), uvB = new THREE.Vector2(), uvC = new THREE.Vector2();

            for (let i = 0; i < faceCount; i++) {
                getPos(i * 3, a);
                getPos(i * 3 + 1, b);
                getPos(i * 3 + 2, c);
                
                const ab = new THREE.Vector3().subVectors(b, a);
                const ac = new THREE.Vector3().subVectors(c, a);
                const area = 0.5 * new THREE.Vector3().crossVectors(ab, ac).length();
                
                areas.push(area);
                totalArea += area;
            }

            let generatedSoFar = 0;
            let cumulativeArea = 0;

            for (let i = 0; i < faceCount; i++) {
                cumulativeArea += areas[i];
                
                const targetCount = Math.floor((cumulativeArea / totalArea) * count);
                const countForFace = targetCount - generatedSoFar;
                
                if (countForFace <= 0) continue;

                getPos(i * 3, a);
                getPos(i * 3 + 1, b);
                getPos(i * 3 + 2, c);
                getUv(i * 3, uvA);
                getUv(i * 3 + 1, uvB);
                getUv(i * 3 + 2, uvC);

                for (let j = 0; j < countForFace; j++) {
                    const r1 = Math.random();
                    const r2 = Math.random();
                    const sqrtR1 = Math.sqrt(r1);
                    const u = 1 - sqrtR1;
                    const v = sqrtR1 * (1 - r2);
                    const w = sqrtR1 * r2;

                    const px = a.x * u + b.x * v + c.x * w;
                    const py = a.y * u + b.y * v + c.y * w;
                    const pz = a.z * u + b.z * v + c.z * w;
                    
                    const ux = uvA.x * u + uvB.x * v + uvC.x * w;
                    const uy = uvA.y * u + uvB.y * v + uvC.y * w;

                    positions[generatedSoFar * 3] = px;
                    positions[generatedSoFar * 3 + 1] = py;
                    positions[generatedSoFar * 3 + 2] = pz;
                    
                    uvs[generatedSoFar * 2] = ux;
                    uvs[generatedSoFar * 2 + 1] = uy;

                    generatedSoFar++;
                }
            }
            
            return { positions, uvs };
        }

        // --- LOADING ---

        const gltfLoader = new GLTFLoader();

        gltfLoader.load(
            MODEL_URL, 
            (gltf) => {
                const model = gltf.scene;
                let geometry = null;
                let texture = null;
                
                model.updateMatrixWorld(true);

                model.traverse((child) => {
                    if (child.isMesh && !geometry) {
                        const tempGeo = child.geometry.clone();
                        tempGeo.applyMatrix4(child.matrixWorld);
                        
                        tempGeo.computeBoundingBox();
                        const center = new THREE.Vector3();
                        tempGeo.boundingBox.getCenter(center);
                        tempGeo.translate(-center.x, -center.y, -center.z);
                        
                        if (child.material.map) {
                            texture = child.material.map;
                        }
                        
                        const sampledData = sampleGeometry(tempGeo, PARTICLE_COUNT);
                        
                        loaderText.innerText = "Optimizing Data...";
                        
                        const count = PARTICLE_COUNT;
                        const shuffledIndices = shuffleIndices(count);
                        
                        const shuffledPos = new Float32Array(count * 3);
                        const shuffledUv = new Float32Array(count * 2);
                        
                        for(let i=0; i<count; i++) {
                            const srcIdx = shuffledIndices[i];
                            const dstIdx = i;
                            
                            shuffledPos[dstIdx*3] = sampledData.positions[srcIdx*3];
                            shuffledPos[dstIdx*3+1] = sampledData.positions[srcIdx*3+1];
                            shuffledPos[dstIdx*3+2] = sampledData.positions[srcIdx*3+2];
                            
                            shuffledUv[dstIdx*2] = sampledData.uvs[srcIdx*2];
                            shuffledUv[dstIdx*2+1] = sampledData.uvs[srcIdx*2+1];
                        }
                        
                        geometry = new THREE.BufferGeometry();
                        geometry.setAttribute('position', new THREE.BufferAttribute(shuffledPos, 3));
                        geometry.setAttribute('uv', new THREE.BufferAttribute(shuffledUv, 2));
                    }
                });

                if (geometry) {
                    particleCount = geometry.attributes.position.count;
                    activeParticleCount = particleCount; 
                    
                    originalPositions = new Float32Array(geometry.attributes.position.array);
                    currentPositions = geometry.attributes.position.array;
                    velocities = new Float32Array(particleCount * 3);
                    
                    particleRandoms = new Float32Array(particleCount);
                    for(let i=0; i<particleCount; i++) particleRandoms[i] = Math.random();
                    
                    geometry.setAttribute('aRandom', new THREE.BufferAttribute(particleRandoms, 1));

                    if (texture) {
                        customUniforms.uTexture.value = texture;
                        customUniforms.uUseTexture.value = true;
                    }

                    const material = new THREE.ShaderMaterial({
                        uniforms: customUniforms,
                        vertexShader: vertexShader,
                        fragmentShader: fragmentShader,
                        transparent: false, 
                        depthWrite: true,   
                        blending: THREE.NormalBlending 
                    });

                    particles = new THREE.Points(geometry, material);
                    particles.frustumCulled = false; 
                    
                    scene.add(particles);
                    
                    loaderElement.classList.add('hidden');
                    
                    lastFpsCheck = performance.now();
                }
            },
            (xhr) => {
                if(xhr.total > 0) {
                    const percent = (xhr.loaded / xhr.total * 100).toFixed(0);
                    loaderText.innerText = `Loading Texture: ${percent}%`;
                }
            }
        );

        // --- MOUSE & TOUCH TRACKING ---

        function updateMouseCoords(x, y) {
            mouse.x = (x / window.innerWidth) * 2 - 1;
            mouse.y = -(y / window.innerHeight) * 2 + 1;
        }

        function resetIdleTimer() {
            lastInteractionTime = Date.now();
        }

        function triggerPulse() {
            pulseIntensity = 0.8; 
            resetIdleTimer();
        }

        window.addEventListener('contextmenu', (e) => e.preventDefault());

        window.addEventListener('mousemove', (event) => {
            updateMouseCoords(event.clientX, event.clientY);
        });

        window.addEventListener('mousedown', (event) => {
            isDragging = true;
            resetIdleTimer(); 
            swirlDirection = (event.button === 2) ? -1.0 : 1.0;
            triggerPulse();
        });

        window.addEventListener('mouseup', () => {
            isDragging = false;
            resetIdleTimer();
        });
        
        window.addEventListener('mouseleave', () => {
            isDragging = false;
        });
        
        window.addEventListener('wheel', () => {
             resetIdleTimer();
        });

        window.addEventListener('touchstart', (event) => {
            if (event.touches.length > 0) {
                isDragging = true;
                swirlDirection = 1.0; 
                resetIdleTimer();
                updateMouseCoords(event.touches[0].clientX, event.touches[0].clientY);
                triggerPulse(); 
                
                dummyPlane.lookAt(camera.position);
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(dummyPlane);
                
                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    prevMouse3D.copy(point);
                    mouse3D.copy(point);
                    customUniforms.uMouse.value.copy(point);
                }
            }
        }, { passive: false });
        
        window.addEventListener('touchend', () => {
            isDragging = false;
            resetIdleTimer();
        });

        window.addEventListener('touchmove', (event) => {
            if (event.touches.length > 0) {
                updateMouseCoords(event.touches[0].clientX, event.touches[0].clientY);
            }
        }, { passive: false });

        // --- ANIMATION ---

        function animate() {
            requestAnimationFrame(animate);

            // Auto-Rotate
            if (!isDragging && Date.now() - lastInteractionTime > IDLE_TIMEOUT) {
                controls.autoRotate = true;
                if (controls.autoRotateSpeed < ROTATION_TARGET_SPEED) {
                    controls.autoRotateSpeed += 0.01;
                }
            } else {
                controls.autoRotate = false;
                controls.autoRotateSpeed = 0;
            }
            
            controls.update();
            
            // --- ADAPTIVE PERFORMANCE LOGIC ---
            const currentTime = performance.now();
            frameCount++;
            
            if (currentTime - lastFpsCheck >= 1000) {
                const fps = frameCount; 
                frameCount = 0;
                lastFpsCheck = currentTime;
                
                if (isDebugVisible) {
                    dbFps.innerText = fps;
                    dbFps.className = 'debug-val ' + (fps > 50 ? 'val-good' : (fps > 30 ? 'val-warn' : 'val-bad'));
                    dbCount.innerText = activeParticleCount.toLocaleString();
                    dbMax.innerText = particleCount.toLocaleString();
                }
                
                if (fps < 35 && activeParticleCount > 10000) {
                    lowFpsStreak++;
                    if (lowFpsStreak >= 2) {
                        const newCount = Math.floor(activeParticleCount * 0.7); // Drop by 30% aggressively
                        activeParticleCount = newCount;
                        
                        particles.geometry.setDrawRange(0, activeParticleCount);
                        
                        console.log(`Low FPS (${fps}). Reducing particles to: ${activeParticleCount}`);
                        
                        // NEW: Hard Optimization (Compaction)
                        // If we are using less than 75% of the allocated buffer, trim the fat.
                        if (activeParticleCount < particleCount * 0.75) {
                             compactBuffers(activeParticleCount);
                        }
                        
                        lowFpsStreak = 0; 
                    }
                } else {
                    lowFpsStreak = 0;
                }
            }

            const now = Date.now();
            const pulseTime = now * 0.006; 

            if (pulseIntensity > 0) {
                pulseIntensity *= 0.92;
                if (pulseIntensity < 0.01) pulseIntensity = 0;
            }

            // Mouse Tracking
            dummyPlane.lookAt(camera.position);
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(dummyPlane);

            if (intersects.length > 0) {
                const intersectionPoint = intersects[0].point;
                mouseVelocity.copy(intersectionPoint).sub(prevMouse3D);
                prevMouse3D.copy(intersectionPoint);
                mouse3D.copy(intersectionPoint);
                customUniforms.uMouse.value.copy(mouse3D);
            } else {
                mouseVelocity.set(0,0,0);
            }
            
            // Interaction State
            const distToCamera = camera.position.distanceTo(mouse3D);
            const zoomScale = distToCamera / 3.0;
            
            const mouseSpeed = mouseVelocity.length();
            const minR = 0.05 * zoomScale;
            const maxR = 0.6 * zoomScale;
            
            const isMoving = mouseSpeed > 0.02; 
            isInteracting = isDragging || isMoving || pulseIntensity > 0;
            
            let targetRadius = 0.01;
            
            if (isDragging) {
                targetRadius = Math.max(mouseSpeed * 4.0, 0.3 * zoomScale);
            } else if (isMoving) {
                targetRadius = Math.max(mouseSpeed * 4.0, 0.1 * zoomScale);
            }
            targetRadius = Math.min(targetRadius, maxR);
            
            if (pulseIntensity > 0) {
                targetRadius = Math.max(targetRadius, pulseIntensity * zoomScale);
            }

            const interactionRadius = isInteracting ? targetRadius : 0.01;
            const interactionRadiusSq = interactionRadius * interactionRadius;
            
            if (isDebugVisible) {
                let stateText = "IDLE";
                if (isDragging) stateText = "DRAGGING";
                else if (isMoving) stateText = "HOVERING";
                else if (controls.autoRotate) stateText = "AUTO-ROTATE";
                
                dbState.innerText = stateText;
                dbInteract.innerText = isInteracting ? "TRUE" : "FALSE";
                dbRadius.innerText = targetRadius.toFixed(2);
                
                if (isInteracting) dbState.className = 'debug-val val-good';
                else if (controls.autoRotate) dbState.className = 'debug-val val-warn';
                else dbState.className = 'debug-val';
            }

            // 2. Physics Simulation
            if (particles && originalPositions && particleRandoms) {
                
                const baseSpringStrength = 0.001; 
                const baseFriction = 0.90;        
                const baseMouseForce = 1.0; 

                for (let i = 0; i < activeParticleCount; i++) {
                    const ix = i * 3;
                    const iy = i * 3 + 1;
                    const iz = i * 3 + 2;

                    let px = currentPositions[ix];
                    let py = currentPositions[iy];
                    let pz = currentPositions[iz];

                    let vx = velocities[ix];
                    let vy = velocities[iy];
                    let vz = velocities[iz];

                    const r = particleRandoms[i];

                    // Spring
                    const dx = originalPositions[ix] - px;
                    const dy = originalPositions[iy] - py;
                    const dz = originalPositions[iz] - pz;
                    
                    const effectiveSpring = baseSpringStrength * (0.5 + r); 
                    
                    vx += dx * effectiveSpring;
                    vy += dy * effectiveSpring;
                    vz += dz * effectiveSpring;

                    // Interaction
                    const mDx = px - mouse3D.x;
                    const mDy = py - mouse3D.y;
                    const mDz = pz - mouse3D.z;
                    const distSq = mDx*mDx + mDy*mDy + mDz*mDz;

                    if (distSq < interactionRadiusSq) {
                        const dist = Math.sqrt(distSq);
                        const influence = (1.0 - (distSq / interactionRadiusSq));
                        
                        if (isInteracting) {
                            const effectiveForce = baseMouseForce * (0.8 + r * 0.4);
                            
                            // 1. Drag Force
                            vx += mouseVelocity.x * effectiveForce * influence * 0.2;
                            vy += mouseVelocity.y * effectiveForce * influence * 0.2;
                            vz += mouseVelocity.z * effectiveForce * influence * 0.2;
                            
                            if (dist > 0.001) {
                                // 2. Whirl / Vortex Force
                                const swirlStrength = 0.15 * (0.5 + r) * swirlDirection;
                                vx += -mDy * swirlStrength * influence; 
                                vy += mDx * swirlStrength * influence;  
                                
                                // 3. Pulsating Radial Force (Heartbeat)
                                const pulsePhase = r * Math.PI * 2; 
                                const pulse = Math.sin(pulseTime + pulsePhase);
                                const radialStrength = 0.05 * pulse * (0.8 + r * 0.4);

                                vx += (mDx / dist) * radialStrength * influence;
                                vy += (mDy / dist) * radialStrength * influence;
                                vz += (mDz / dist) * radialStrength * influence;
                            }
                            
                            // 3. Pulse (Impact)
                            if (pulseIntensity > 0) {
                                const pulseForce = pulseIntensity * 0.05;
                                vx += (mDx / dist) * pulseForce * influence;
                                vy += (mDy / dist) * pulseForce * influence;
                                vz += (mDz / dist) * pulseForce * influence;
                            }
                        }
                    }

                    // Friction
                    vx *= baseFriction;
                    vy *= baseFriction;
                    vz *= baseFriction;

                    px += vx;
                    py += vy;
                    pz += vz;

                    currentPositions[ix] = px;
                    currentPositions[iy] = py;
                    currentPositions[iz] = pz;
                    velocities[ix] = vx;
                    velocities[iy] = vy;
                    velocities[iz] = vz;
                }

                particles.geometry.attributes.position.needsUpdate = true;
                
                // CRITICAL: Only update the range of active particles to save bandwidth
                particles.geometry.attributes.position.updateRange.count = activeParticleCount * 3;
            }
            
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            customUniforms.uPixelRatio.value = window.devicePixelRatio;
        });
    </script>
</body>
</html>